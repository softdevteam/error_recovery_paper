\documentclass[acmsmall,small,screen]{acmart}\settopmatter{printfolios=true,printccs=false,printacmref=false}
%\documentclass[acmsmall,review,anonymous]{acmart}\settopmatter{printfolios=true,printccs=false,printacmref=false}

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}

\usepackage{listings}
\usepackage{booktabs} % For formal tables
\usepackage{softdev}
\usepackage{subcaption}
\usepackage{xspace}

\usepackage[ruled]{algorithm2e} % For algorithms
\renewcommand{\algorithmcfname}{ALGORITHM}
\SetAlFnt{\small}
\SetAlCapFnt{\small}
\SetAlCapNameFnt{\small}
\SetAlCapHSkip{0pt}
\IncMargin{-\parindent}

\acmJournal{PACMPL}
\acmVolume{1}
\acmNumber{CONF} % CONF = POPL or ICFP or OOPSLA
\acmArticle{1}
\acmYear{2018}
\acmMonth{1}
\acmDOI{} % \acmDOI{10.1145/nnnnnnn.nnnnnnn}
\startPage{1}

\lstset{
    basicstyle=\tt\scriptsize,
    xleftmargin=0pt,
    framexleftmargin=1.5em,
    numberstyle=\scriptsize\tt\color{gray},
    captionpos=b,
    escapeinside={{<!}{!>}},
}

\setcopyright{none}

\bibliographystyle{ACM-Reference-Format}
\citestyle{acmauthoryear}

% DOI
%\acmDOI{0000001.0000001}

% Paper history
%\received{February 2007}

\newcommand{\corchueloplus}{\textit{CPCT}$^+$\xspace}
\newcommand{\mf}{\textit{MF}\xspace}

% Document starts
\begin{document}
% Title portion. Note the short title for running heads
\title[Fast Multiple Repair Error Recovery]{Fast Multiple Repair Error Recovery}

\author{Lukas Diekmann}
\affiliation{%
  \department{Software Development Team}
  \institution{King's College London}
  \country{United Kingdom}}
\author{Laurence Tratt}
\orcid{0000-0002-5258-3805}
\affiliation{%
  \department{Software Development Team}
  \institution{King's College London}
  \country{United Kingdom}
}
\thanks{Authors' URLs: %
    L.~Diekmann~\url{http://diekmann.co.uk/},
    L.~Tratt~\url{http://tratt.net/laurie/}.
}


\begin{abstract}
Syntax errors are generally easy to fix for humans, but not for compilers: the
latter often choose incorrect repairs, leading to a cascading chain of errors that drown out the
original. More advanced error recovery techniques discover repair sequences,
reducing the problem of cascading errors. However, they arbitrarily select a
single repair sequence from the set of possibilities: not only is the chosen
sequence often not what the user would have selected, but it still often
causes cascading errors. Worse, such approaches have
unbounded worse case performance.

In this paper we show -- first by extending an existing algorithm, second by
introducing a new, faster, alternative -- how the complete set of minimal cost repair sequences
can be generated. Not only does this increase the chance of the user seeing a
relevant repair sequence, but it allows us to rank repair sequences and choose one
which lessens the chances of cascading errors. Using a corpus of
\laurie{1,000,000?} human-generated syntactically invalid of Java programs, we
then show that, even when used with a tight timeout of 0.5s, our new error
recovery algorithm can find the complete set of minimal repair sequences in
\laurie{99\%?} of cases.
\end{abstract}

\keywords{Parsing, error recovery, programming languages}

\maketitle

\section{Introduction}

Programming is a humbling job, which involves acknowledging that we will make
untold errors in our quest to perfect a program. Most troubling are semantic
errors, where we intended the program to do one thing, but it does another. Less
troubling, but often no less irritating, are syntax errors, which are
(generally minor) deviances from the exacting syntax required by a compiler.
So common are syntax errors that modern compilers expect us to make several
in a single input. Rather than stop on the first syntax error encountered, they attempt
to \emph{recover} from it. This allows them to report, and us to fix, all our
syntax errors in one go.

When error recovery works well, it is a useful productivity gain. Unfortunately,
widely used approaches are ad-hoc, with
two weaknesses limiting their usefulness: only limited consideration is
given to the context of the error; and the only recoveries attempted are the
skipping of input until a pre-determined synchronisation
token is reached~\cite[p.~3]{degano95comparison} or the insertion of a
single synchronisation token. Inappropriate repairs cause a cascade of spurious syntax errors (see
Figure~\ref{fig:javaerror} for an example): programmers quickly learn that
only the position of the first error -- not its repair, nor the position of
subsequent errors -- can really be relied upon to be accurate.

Most of us are so used to this state of affairs that
we assume it to be inevitable. However, there are more advanced approaches which:
are grammar neutral; take into account the full context of the error; and have
more options for recovering from errors. Probably the earliest such approach
is \citet{aho72minimum}, which, upon encountering an error, creates on-the-fly an
alternative (possibly ambiguous) grammar which allows the parser to recover.
The implementation complexity of this approach, and the challenge of explaining
to users what has been done, probably explain why it has fallen out of
favour in programming language circles. A simpler approach, which
traces its roots to \citet{fischer79locally}, instead tries to find a single minimal cost
\emph{repair sequence} of token insertions and deletions which allow the parser to
recover. This approach is good at recovering from errors and is
easily adapted to give human-friendly feedback. However, such approaches
have seen little practical use because their typical
performance was seen as poor and their worse case unbounded \cite[p.~14]{mckenzie95error}.

In this paper we test the following hypothesis:

\begin{description}
  \item[H1] A \citet{fischer79locally} approach can repair nearly all errors in
    acceptable time.
\end{description}

We impose a strict budget of 0.5s for error recovery (i.e.~all errors must be
recovered within this time) since we think that even the most demanding user
will accept that small delay in order to get better quality parses. To a
reasonable extent, our access to faster hardware makes it more likely that we
can validate this hypothesis than past researchers. However, not only do we
validate this hypothesis, but we do so while finding \emph{all} minimal cost
repair sequences in acceptable time. In other words, we are able to tackle a
harder version of the problem than any previous approach, and do so in
acceptable time. This not only leads to higher quality, and more programmer
friendly, error messages (see Figure~\ref{fig:javaerror} for an example), but
allows us to reduce the cascading error problem.

We first use one of the more recent algorithms in this family -- that of
\citet{corchuelo02repairing} -- as a base, slightly correcting and extending it
to form an algorithm called \corchueloplus (Section~\ref{corchueloplus}). We
then show that an even newer algorithm which promises better performance -- that
of \citet{kimyi10astar} -- has several weaknesses which cause it to miss many
minimal cost repair sequences (Section~\ref{kimyi}). However, we are able to use
this as partial inspiration for an entirely new error recovery algorithm \mf
(Section~\ref{mf}) which is approximately \laurie{2x} faster than
\corchueloplus. We aim for both algorithms to be as simple as possible, so that
tool builders can reasonably incorporate them: \corchueloplus is somewhat
simpler than \mf, though the latter is still less than 1,000 lines of Rust code.

We then validate \corchueloplus and \mf on a corpus of \laurie{1,000,000?} real,
syntactically incorrect, Java programs (Section~\ref{experiment}). Within the
time budget of 0.5s: \corchueloplus is able to find repairs for \laurie{XX\%{}}
of files within this time, with an average recovery time of \laurie{XXs}; and
\mf is able to find repairs for \laurie{XX\%{}} of files within this time, with
an average recovery time of \laurie{XXs}. We believe that this shows that such
approaches are ready for wider usage.


\begin{figure}[t]
\begin{minipage}{0.48\textwidth}
\begin{tabular}{p{0.02\textwidth}p{0.45\textwidth}}
\begin{subfigure}{0.02\textwidth}
\caption{}
\label{lst:javaerror:input}
\end{subfigure}
&
\begin{minipage}[t]{0.45\textwidth}
\vspace{-7pt}
\begin{lstlisting}
class C {
  int x y;
}
\end{lstlisting}
\end{minipage}
\\
\begin{subfigure}{0.02\textwidth}
\addtocounter{subfigure}{1}
\caption{}
\label{lst:javaerror:mf}
\end{subfigure}
&
\begin{minipage}[t]{0.45\textwidth}
\vspace{-7pt}
\begin{lstlisting}
Error at line 2 col 9. Repairs found:
  Delete "y"
  Insert "COMMA"
  Insert "EQ"
\end{lstlisting}
\end{minipage}
\end{tabular}
\end{minipage}
%
\begin{minipage}{0.48\textwidth}
\vspace{-20.5pt}
\begin{tabular}{p{0.02\textwidth}p{0.45\textwidth}}
\begin{subfigure}{0.02\textwidth}
\addtocounter{subfigure}{-2}
\caption{}
\label{lst:javaerror:javac}
\end{subfigure}
&
\begin{minipage}[t]{0.45\textwidth}
\vspace{-7pt}
\begin{lstlisting}
C.java:2: error: ';' expected
  int x y;
       ^
C.java:2: error: <identifier> expected
  int x y;
         ^
\end{lstlisting}
\end{minipage}
\end{tabular}
\end{minipage}
%&
%\begin{minipage}[t]{0.47\textwidth}
%\vspace{-17pt}
\vspace{-10pt}
\caption{An example of a simple, common Java syntax error
(\subref{lst:javaerror:input}) and the problems traditional error recovery has in
dealing with it. \texttt{javac} (\subref{lst:javaerror:javac}) spots the error
when it encounters `\texttt{y}'. Its error recovery heuristic then
repairs the input by inserting a semicolon before `\texttt{y}' (i.e.~making
the input equivalent to `\texttt{int x; y;}'). This immediately leads to a spurious second parse error,
since `\texttt{y}' on its own is not a valid statement. The \corchueloplus and \mf
recovery algorithms (both produce the output shown in \subref{lst:javaerror:mf}) also spot the
error when it encounters `\texttt{y}', and then use the
Java grammar to find minimal cost repair sequences. These two algorithms find
and report to the user three separate repair sequences: one can delete `\texttt{y}'
entirely (`\texttt{int x;}'), or insert a comma
(`\texttt{int x, y;}'), or insert an equals sign (\texttt{`int x = y;'}). In
this case, all three repair sequences have the same rank, and are thus presented
in an arbitrary order. However, it is important to note that the first repair
sequence is then used to repair the input for subsequent parsing. Presenting all
three minimal cost repair sequences to the user gives a much greater chance that one
matches their original intention.}
\label{fig:javaerror}
%\end{minipage}
%\end{tabular}
\end{figure}


\section{Related work}

\cite{corchuelo02repairing}

\cite{deJonge12natural}

\cite{pottier16reachability}

\cite{gomezrodriguez10error}

\bibliography{bib}

\end{document}
