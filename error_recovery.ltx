\documentclass[acmsmall,small,screen]{acmart}\settopmatter{printfolios=true,printccs=false,printacmref=false}
%\documentclass[acmsmall,review,anonymous]{acmart}\settopmatter{printfolios=true,printccs=false,printacmref=false}

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}

\usepackage{listings}
\usepackage{booktabs} % For formal tables
\usepackage{softdev}
\usepackage{subcaption}

\usepackage[ruled]{algorithm2e} % For algorithms
\renewcommand{\algorithmcfname}{ALGORITHM}
\SetAlFnt{\small}
\SetAlCapFnt{\small}
\SetAlCapNameFnt{\small}
\SetAlCapHSkip{0pt}
\IncMargin{-\parindent}

\acmJournal{PACMPL}
\acmVolume{1}
\acmNumber{CONF} % CONF = POPL or ICFP or OOPSLA
\acmArticle{1}
\acmYear{2018}
\acmMonth{1}
\acmDOI{} % \acmDOI{10.1145/nnnnnnn.nnnnnnn}
\startPage{1}

\lstset{
    basicstyle=\tt\scriptsize,
    xleftmargin=0pt,
    framexleftmargin=1.5em,
    numberstyle=\scriptsize\tt\color{gray},
    captionpos=b,
    escapeinside={{<!}{!>}},
}

\setcopyright{none}

\bibliographystyle{ACM-Reference-Format}
\citestyle{acmauthoryear}

% DOI
%\acmDOI{0000001.0000001}

% Paper history
%\received{February 2007}


% Document starts
\begin{document}
% Title portion. Note the short title for running heads
\title[Fast Multiple Repair Error Recovery]{Fast Multiple Repair Error Recovery}

\author{Lukas Diekmann}
\affiliation{%
  \department{Software Development Team}
  \institution{King's College London}
  \country{United Kingdom}}
\author{Laurence Tratt}
\orcid{0000-0002-5258-3805}
\affiliation{%
  \department{Software Development Team}
  \institution{King's College London}
  \country{United Kingdom}
}
\thanks{Authors' URLs: %
    L.~Diekmann~\url{http://diekmann.co.uk/},
    L.~Tratt~\url{http://tratt.net/laurie/}.
}


\begin{abstract}
Syntax errors are generally easy to fix for humans, but not for compilers: the
latter often choose incorrect repairs, leading to a cascading chain of errors that drown out the
original. More advanced error recovery techniques discover repair sequences,
reducing the problem of cascading errors. However, they arbitrarily select a
single repair sequence from the set of possibilities: the chosen sequence still
often causes cascading errors; and the chosen sequence is often not what the
user would have selected, thus confusing them. Worse, such approaches have
unbounded worse case performance.

In this paper we show -- first by extending an existing algorithm, second by
introducing a new, faster, alternative -- that
it is possible to generate the complete set of minimal cost repair sequences in
only slightly more time \laurie{can we quantify it?} than is needed for a single
repair sequence. This allows us to then rank repair sequences by how far they
allow parsing to continue and removes any low-ranking sequences. This significantly
reduces the cascading error problem, while still reporting all high-ranking
sequences to the user, increasing the chance that one matches their expectation.
After putting a 0.5s bound on error
recovery, we show that, on a corpus of \laurie{1,000,000?} real-world syntactically invalid Java
programs, this finds the complete set of minimal cost repairs in \laurie{99\%?}
of cases.
\end{abstract}

\keywords{Parsing, error recovery, programming languages}

\maketitle

\section{Introduction}

Programming is a humbling job, which involves acknowledging that we will make
untold errors in our quest to perfect a program. Most troubling are semantic
errors, where we intended the program to do one thing, but it does another. Less
troubling, but often more irritating, are syntax errors, which are
(generally minor) deviances from the exacting syntax required by a compiler.
So common are syntax errors that modern compilers expect us to make several
in a single input. Rather than stopping on the first syntax error, they attempt
to \emph{recover} from it. This allows them to report, and us to fix, all our
syntax errors in one go.

When error recovery works well, it is a
useful productivity gain. Unfortunately, current compilers use simplistic and
ad-hoc approaches to error recovery, which often lead to inappropriate
\emph{repairs} being found. The result is a cascade of spurious syntax errors,
each the result of the first incorrect repair: programmers quickly learn that
only the position of the first error -- not its repair, nor the position of
subsequent errors -- can really be relied upon to be accurate.

\begin{figure}[t]
\begin{minipage}{0.48\textwidth}
\begin{tabular}{p{0.02\textwidth}p{0.45\textwidth}}
\begin{subfigure}{0.02\textwidth}
\caption{}
\label{lst:javaerror}
\end{subfigure}
&
\begin{minipage}[t]{0.45\textwidth}
\vspace{-7pt}
\begin{lstlisting}
class C {
  int x y;
}
\end{lstlisting}
\end{minipage}
\\
\begin{subfigure}{0.02\textwidth}
\addtocounter{subfigure}{1}
\caption{}
\label{lst:javaerror:mf}
\end{subfigure}
&
\begin{minipage}[t]{0.45\textwidth}
\vspace{-7pt}
\begin{lstlisting}
Error at line 2 col 9. Repairs found:
  Delete "y"
  Insert "COMMA"
  Insert "EQ"
\end{lstlisting}
\end{minipage}
\end{tabular}
\end{minipage}
%
\begin{minipage}{0.48\textwidth}
\vspace{-20.5pt}
\begin{tabular}{p{0.02\textwidth}p{0.45\textwidth}}
\begin{subfigure}{0.02\textwidth}
\addtocounter{subfigure}{-2}
\caption{}
\label{lst:javaerror:javac}
\end{subfigure}
&
\begin{minipage}[t]{0.45\textwidth}
\vspace{-7pt}
\begin{lstlisting}
C.java:2: error: ';' expected
  int x y;
       ^
C.java:2: error: <identifier> expected
  int x y;
         ^
\end{lstlisting}
\end{minipage}
\end{tabular}
\end{minipage}
%&
%\begin{minipage}[t]{0.47\textwidth}
%\vspace{-17pt}
\vspace{-10pt}
\caption{An example of a simple, common Java syntax error
(\subref{lst:javaerror}) and the problems traditional error recovery has in
dealing with it. \texttt{javac} (\subref{lst:javaerror:javac}) spots the error
when it encounters `\texttt{y}'. Its error recovery heuristic then
repairs the input by inserting a semicolon before `\texttt{y}' (i.e.~making
the input equivalent to `\texttt{int x; y;}'). This immediately leads to a spurious second parse error,
since `\texttt{y}' on its own is not a valid statement. Our new recovery
approach (\subref{lst:javaerror:mf}) also spots the
error when it encounters `\texttt{y}', and then uses the
Java grammar to find minimal cost repair sequences. In this case, it finds
and reports to the user three separate repair sequences: one can delete `\texttt{y}'
entirely (`\texttt{int x;}'), or insert a comma
(`\texttt{int x, y;}'), or insert an equals sign (\texttt{`int x = y;'}).
The first repair sequence is then used to repair the input for subsequent
parsing. Presenting all three
minimal cost repair sequences to the user gives a much greater chance that one
matches their original intention.}
%\end{minipage}
%\end{tabular}
\end{figure}


We are so used to this state of affairs that we assume it to be inevitable.
However, there has been a slowly growing body of work on more advanced error
recovery approaches (see~\cite{cereke03phd} for a good general overview and
\cite{kimyi10astar,deJonge12natural} for more recent work).



\section{Related work}

\cite{corchuelo02repairing}

\cite{deJonge12natural}

\bibliography{bib}

\end{document}
